#include "minishell.h"
#define BUF_SIZE 1024
#define MAXLINE 1024

static void check_command(char *s)
{
    if (ft_strchri(s, ';') != -1)
        ft_putendl("THERE IS IT ;");
    if (ft_strcmp(s, "cd\n") == 0)
        ft_putendl("cd");
    else if (ft_strcmp(s, "echo\n") == 0)
        ft_putendl("echo");
    else if (ft_strcmp(s, "exit\n") == 0)
    {
        ft_putendl("exit");
        exit (1);
    }
    else
        ft_putendl("OTHER");
}

void    handle_sig(int sig)
{
    if (sig == 1)
        printf("Hangup the process %d\n", sig);
    else if (sig == 2)
        printf("Interrupt the process %d\n", sig);
    else if (sig == 3)
        printf("Quit the process %d\n", sig);
    else if (sig == 4)
        printf("Illegal instruction %d\n", sig);
    else if (sig == 5)
        printf("Trace trap %d\n", sig);
    else if (sig == 6)
        printf("Abort %d\n", sig);
}

// static void     signal_check(void)
// {
//     //signal(SIGHUP, handle_sig);
//     printf("%s\n", signal(SIGINT, handle_sig));
//     // signal(SIGQUIT, handle_sig);
//     // signal(SIGILL, handle_sig);
//     // signal(SIGTRAP, handle_sig);
//     // signal(SIGABRT, handle_sig);
// }

int         main(void)
{
    char buf[MAXLINE]; /* из apue.h */
    pid_t pid;
    int status;

    printf("%% "); /* вывести приглашение (printf требует использовать */
    /* последовательность %%, чтобы вывести символ %) */
    while (fgets(buf, MAXLINE, stdin) != NULL)
    {
        if (buf[strlen(buf) - 1] == '\n')
            buf[strlen(buf) - 1] = 0; /* заменить символ перевода строки */
        if ((pid = fork()) < 0)
        {
            ft_putendl("fork error");
        }
        else if (pid == 0)
        { /* дочерний процесс */
            execlp(buf, buf, (char *)0);
            printf("can't make: %s\n", buf);
            exit(127);
        }
        /* родительский процесс */
        if ((pid = waitpid(pid, &status, 0)) < 0)
            ft_putendl("waitpid error");
        printf("%% ");
    }
    ft_putchar('\n');
    exit(0);
    // int     ret;
    // char    command[BUF_SIZE + 1];

    // while (1)
    // {
	// 	ft_putstr("$> ");
    //     if (signal(SIGINT, handle_sig))
    //     ret = read(STDIN_FILENO, command, BUF_SIZE);
    //     if (command[ret - 1] == '\n')
    //         check_command(command);
    //     if (ret == 0 || command[ret - 1] == '\0')
    //     {
    //         ft_putendl("exit");
    //         exit(1);
    //     }
    //     ft_bzero(command, BUF_SIZE + 1);
    // }
    // exit(0);
}

while (*envp++)
    {
        printf("%s\n", *envp);
    }

Version 25.08 10:48

static void         noncanonical_input(void)
{
    struct termios  backup_tty;
    struct termios  tty;
    char            c;

    // if (!isatty(0))
    //     error('T');
    tcgetattr (0, &tty);
    backup_tty = tty;
    printf("%ld\n", tty.c_lflag);
    tty.c_lflag &= ~(ICANON | ECHO | ISIG);
    tty.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    tty.c_cflag &= ~(CSIZE | PARENB);
    tty.c_oflag &= ~(OPOST);
    tty.c_cflag |= CS8;
    printf("%ld\n", tty.c_lflag);
    tty.c_cc[VMIN] = 1;
    tty.c_cc[VTIME] = 0;
    tty.c_cc[VINTR] = _POSIX_VDISABLE;
    fflush (stdout);
    while (1)
    {
        display_prompt();
        read(0, &c, 1);
        if (c == '\n')
            continue ;
        else if (c == 'D')
            break;
    }
    tcsetattr (0, TCSAFLUSH, &backup_tty);
    ft_putendl(0);
    exit(0);
}

OLD REDLINE
        else if ((c >= ' ' && c <= '~')
        {
            write(STDOUT_FILENO, &c, 1);
            if (i >= max - 1)
            {
                cmd = ft_realloc(*cmd, max, max * 2);
                max *= 2;
            }
            *cmd[++i] = c;
            if (c == '#')
                signal = 1;
        }
    }
    *cmd[i] = '\0';
    if ((*cmd[0] == '^' && *cmd[1] == 'C') || (*cmd[0] == ':' && i == 1) || signal == 1)
        return (1);
    else if (*cmd[0] == '^' && *cmd[1] == 'D')
        return (-1);

OLD READLINE
static void	    get_terminal_width(int *term)
{
	struct winsize	sz;

	ioctl(1, TIOCGWINSZ, &sz);
    term[0] = sz.ws_col;
    term[1] = sz.ws_row;
}

int            readline(void)
{
    char        *cmd;
    int         max;
    unsigned char        c;
    int         i;
    int         sig;
    static int  term[4];

    max = 50;
    cmd = (char*)ft_xmalloc(max);
    i = -1;
    sig = 0;
    get_terminal_width(term);
    term[2] = 0;
    while (c != '\n')
    {
        read(STDIN_FILENO, &c, 1);
        if (ft_isprint(c) && !(sig & FLAG_ESC))
        {
            i++;
            write(STDOUT_FILENO, &c, 1);
            (c == ';') ? sig |= FLAG_SCMD : 0;
            (c == '#' || c == ':') ? sig |= FLAG_NL : 0;
            if (i >= max - 1)
            {
                cmd = ft_realloc(cmd, max, max * 2);
                max *= 2;
            }
            cmd[i] = c;
        }
        // if (ft_isprint(c) && !(sig & FLAG_ESC))
        //     term[2]++;

        //reaction for signals
        if (c == 3 || c == 10 || c == 13)
        {
            ft_putchar('\n');
            return (1);
        }
        (c == 4 && !cmd[0]) ? cmd_exit(cmd) : 0;

        //switches
        (c == '\033') ? sig |= FLAG_ESC : 0;
        (c == 91 && (sig & FLAG_ESC)) ? sig |= FLAG_OSQBRK : 0;
        if (c == 68 && (sig & FLAG_ESC) && (sig & FLAG_OSQBRK))
        {
            // if (term[2] > 0)
            // {
            //     write(STDOUT_FILENO, "\033[D", 3);
            //     term[2]--;
            // }
            if (i >= 0)
            {
                write(STDOUT_FILENO, "\033[D", 3);
                i--;
            }
        }
        else if (c == 67 && (sig & FLAG_ESC) && (sig & FLAG_OSQBRK))
        {
            write(STDOUT_FILENO, "\033[C", 3);
            i++;
            //term[2]++;
        }

        //delete
        if (c == 127)
        {
            if (i >= 0)
            {
                write(STDOUT_FILENO, "\033[D \033[D", 7);
                // write(STDOUT_FILENO, " ", 1);
                // write(STDOUT_FILENO, "\033[D", 3);
                (i >= 0) ? cmd[i] = '\0' : 0;
                i--;
            }
            // if (term[2] > 0)
            // {
            //     write(STDOUT_FILENO, "\033[D \033[D", 7);
            //     // write(STDOUT_FILENO, " ", 1);
            //     // write(STDOUT_FILENO, "\033[D", 3);
            //     (i >= 0) ? cmd[i] = '\0' : 0;
            //     i--;
            //     term[2]--;
            // }
        }

        // if (ft_isprint(c) && !(sig & FLAG_ESC))
        // {
        //     i++;
        //     write(STDOUT_FILENO, &c, 1);
        //     (c == ';') ? sig |= FLAG_SCMD : 0;
        //     (c == '#' || c == ':') ? sig |= FLAG_NL : 0;
        //     if (i >= max - 1)
        //     {
        //         cmd = ft_realloc(cmd, max, max * 2);
        //         max *= 2;
        //     }
        //     cmd[i] = c;
        // }
        //ft_putendl("OUT");
    }

    // if (signal = NEXTLINE && cmd[0] == ':' && cmd[1] == ' ')
    // {
    //     ft_putchar('\n');
    //     return (1);
    // }
    return (0);
}

void            display_prompt(void)
{
    ft_putstr("$> ");
}

THE LAST Version
// max = 50;
    // cmd = (char*)ft_xmalloc(max);
    // i = -1;
    // sig = 0;
    // get_terminal_width(term);
    while (c != '\n')
    {
        read(STDIN_FILENO, &c, 1);
        if (ft_isprint(c) && !(sig & FLAG_ESC))
        {
            all[2]++;
            write(STDOUT_FILENO, &c, 1);
            (c == ';') ? sig |= FLAG_SCMD : 0;
            (c == '#' || c == ':') ? sig |= FLAG_NL : 0;
            if (i >= max - 1)
            {
                cmd = ft_realloc(cmd, max, max * 2);
                max *= 2;
            }
            cmd[i] = c;
        }

        //reaction for signals
        if (c == 3 || c == 10 || c == 13)
        {
            ft_putchar('\n');
            return (1);
        }
        (c == 4 && !cmd[0]) ? cmd_exit(cmd) : 0;

        //switches
        (c == '\033') ? sig |= FLAG_ESC : 0;
        (c == 91 && (sig & FLAG_ESC)) ? sig |= FLAG_OSQBRK : 0;
        if (c == 68 && (sig & FLAG_ESC) && (sig & FLAG_OSQBRK))
        {
            if (i >= 0)
            {
                write(STDOUT_FILENO, "\033[D", 3);
                i--;
            }
        }
        else if (c == 67 && (sig & FLAG_ESC) && (sig & FLAG_OSQBRK))
        {
            write(STDOUT_FILENO, "\033[C", 3);
            i++;
        }

        //delete
        if (c == 127)
        {
            if (i >= 0)
            {
                write(STDOUT_FILENO, "\033[D \033[D", 7);
                (i >= 0) ? cmd[i] = '\0' : 0;
                i--;
            }
        }

STR_ADD_SYMBOL
char            *new;
    int             i;

    i = all[3] - PROMPT;
    all[7] = ft_strlen(cmd) + 1 + 1;
    new = (all[7] > all[0]) ? (char*)ft_xmalloc((all[0] = all[0] *
        (all[7] / all[0] + 1))) : (char*)ft_xmalloc(all[0]);
    // ft_putnbr(all[0]);
    // ft_putchar('\n');
    if (!(cmd[i] >= ' ' && cmd[i] <= '~'))
    {
        ft_strcpy(new, cmd); //add to the end of the string
        if (cmd[i - 1] == '\0') //counter is among '\0'
        {
            while (i > 0 && new[i - 1] == '\0')
                i--;
            all[3] = i + PROMPT;
        }
    }
    if (cmd[i] != '\0') //add to some part of the string
    {
        ft_strncpy(new, cmd, i);
        ft_strcpy(new + i + 1, cmd + i);
    }
    new[i] = add;
    all[3]++;
    all[2]++;
    free(cmd);

    {
            cmd[all[2] - PROMPT] = ' ';
            all[2]++;
        }

ECHO
if (cmd[i] == '"')
        {
            flag = (flag & ECHO_OQUT) ? flag ^ ECHO_OQUT : flag | ECHO_OQUT;
            i++;
        }
        ((cmd[i] == '\\') && !(flag & ECHO_OQUT)) ? i++ : 0;
        if ((cmd[i] == '\\') && (flag & ECHO_OQUT) && (flag & ECHO_E))
        {
            if (cmd[i + 1] == '\\' || (cmd[i + 1] >= 'a' && cmd[i + 1] <= 'c')
                || cmd[i + 1] == 'e' || cmd[i + 1] == 'f' || cmd[i + 1] == 'n'
                || cmd[i + 1] == 'r' || cmd[i + 1] == 't' || cmd[i + 1] == 'v'
                || cmd[i + 1] == 'E')
            {
                c[0] = '\\';
                c[1] = cmd[i];
                write(STDOUT_FILENO, &c, 1);
            }
            else if (ft_strncmp(cmd + i + 1, "033", 3) == 0)
            {
                write(STDOUT_FILENO, "\033", 1);
                i += 4;
            }
            else
            {
                write(STDOUT_FILENO, &cmd[i], 1);
                write(STDOUT_FILENO, &cmd[i + 1], 1);
                i += 2;
            }
        }
        else
            write(STDOUT_FILENO, &cmd[i++], 1);

LAST ECHO
if (cmd[i] == '\\' && (flag & ECHO_E))
            {
                if (cmd[i + 1] == '\\' || (cmd[i + 1] >= 'a' && cmd[i + 1] <= 'c')
                || cmd[i + 1] == 'e' || cmd[i + 1] == 'f' || cmd[i + 1] == 'n'
                || cmd[i + 1] == 'r' || cmd[i + 1] == 't' || cmd[i + 1] == 'v'
                || cmd[i + 1] == 'E')
                {
                    c[0] = '\\';
                    c[1] = cmd[i];
                    write(STDOUT_FILENO, &c, 1);
                    i++;
                }
                else if (ft_strncmp(cmd + i + 1, "033", 3) == 0)
                {
                    write(STDOUT_FILENO, "\033", 1);
                    i += 3;
                }
                else
                {
                    write(STDOUT_FILENO, &cmd[i], 1);
                    write(STDOUT_FILENO, &cmd[i + 1], 1);
                    i++;
                }
            }
            else if (cmd[i] == '\\' && (flag & ECHO_EE))
                write(STDOUT_FILENO, &cmd[i], 1);

LAST LAST
(cmd[++i] == 'b') ? write(STDOUT_FILENO, "\b", 1) : i--;
            (cmd[++i] == 'f') ? write(STDOUT_FILENO, "\f", 1) : i--;
            (cmd[++i] == 'n') ? write(STDOUT_FILENO, "\n", 1) : i--;
            (cmd[++i] == 'r') ? write(STDOUT_FILENO, "\r", 1) : i--;
            (cmd[++i] == 't') ? write(STDOUT_FILENO, "\t", 1) : i--;
            (cmd[++i] == 'v') ? write(STDOUT_FILENO, "\v", 1) : i--;
            if (ft_strncmp(cmd + i + 1, "033", 3) == 0 || ft_strncmp(cmd + i + 1, "x1b", 3) == 0)
            {
                write(STDOUT_FILENO, "\033", 1);
                i += 3;
            }
        }
        i += (cmd[i] == '\\' && !(flag & ECHO_OQUT)) ? 1 : 0;
        write(STDOUT_FILENO, &cmd[i], 1);
        i++;


 if (cmd[++i] == 'a')
                write(STDOUT_FILENO, "\a", 1);
            (cmd[++i] == 'b') ? write(STDOUT_FILENO, "\b", 1) : i--;
            (cmd[++i] == 'f') ? write(STDOUT_FILENO, "\f", 1) : i--;
            (cmd[++i] == 'n') ? write(STDOUT_FILENO, "\n", 1) : i--;
            (cmd[++i] == 'r') ? write(STDOUT_FILENO, "\r", 1) : i--;
            (cmd[++i] == 't') ? write(STDOUT_FILENO, "\t", 1) : i--;
            (cmd[++i] == 'v') ? write(STDOUT_FILENO, "\v", 1) : i--;
            (cmd[++i] == '"') ? write(STDOUT_FILENO, "\"", 1) : i--;
            if (cmd[++i] == 'e' || ft_strncmp(cmd + i + 1, "033", 3) == 0
                || ft_strncmp(cmd + i + 1, "x1b", 3) == 0)
            {
                write(STDOUT_FILENO, "\033", 1);
                i += 2;
            }
            i++;
            \


void        cmd_echo_output(char *cmd, int len, int flag, int i)
{
    //ft_putendl(cmd + i);
    while (i < len)
    {
        if (cmd[i++] == '"')
            flag = (flag & ECHO_OQUT) ? flag ^ ECHO_OQUT : flag | ECHO_OQUT;
        if (flag & ECHO_OQUT && (flag & ECHO_E) && cmd[i] == '\\')
        {
            i++;
            // if (cmd[i] == 'a')
            // {
            //     write(STDOUT_FILENO, "\a", 1);
            //     i++;
            // }
            // else if (cmd[i] == 'b')
            // {
            //     write(STDOUT_FILENO, "\b", 1);
            //     i++;
            // }
            // else if (cmd[i] == 'f')
            // {
            //     write(STDOUT_FILENO, "\f", 1);
            //     i++;
            // }
            // else if (cmd[i] == 'n')
            // {
            //     write(STDOUT_FILENO, "\n", 1);
            //     i++;
            // }
            // else if (cmd[i] == 'r')
            // {
            //     write(STDOUT_FILENO, "\r", 1);
            //     i++;
            // }
            // else if (cmd[i] == 't')
            // {
            //     write(STDOUT_FILENO, "\t", 1);
            //     i++;
            // }
            // else if (cmd[i] == 'v')
            // {
            //     write(STDOUT_FILENO, "\v", 1);
            //     i++;
            // }
            // else if (cmd[i] == '"')
            // {
            //     write(STDOUT_FILENO, "\"", 1);
            //     i++;
            // }
            if (ft_strncmp(cmd + i, "033", 3) == 0
                || ft_strncmp(cmd + i, "x1b", 3) == 0)
            {
                write(STDOUT_FILENO, "\033", 1);
                i += 3;
            }
        }
        i += (cmd[i] == '\\' && !(flag & ECHO_OQUT)) ? 1 : 0;
        (cmd[i] == '"') ? 0 : write(STDOUT_FILENO, &cmd[i++], 1);
        //i++;
    }
    if (flag & ECHO_OQUT)
        write(STDOUT_FILENO, "Close the brackets", 19);
    // (ptr = ft_strchr(cmd, '"')) ? flag |= ECHO_OQUT : 0;
    // if (ft_strrchr(ptr + 1, '"') && (flag & ECHO_EE))
    //     write(STDOUT_FILENO, ptr + 1, ft_strlen(ptr + 1) - 1);
}

LAST ECHO OUTPUT - 12.09

void        cmd_echo_output(char *cmd, int len, int *flag, int i)
{
    //ft_putendl(cmd + i);
    while (i < len)
    {
        if (cmd[i] == '"')
        {
            *flag = (*flag & ECHO_OQUT) ? *flag ^ ECHO_OQUT : *flag | ECHO_OQUT;
            i++;
        }
        if ((*flag & ECHO_OQUT) && (*flag & ECHO_E) && cmd[i] == '\\')
        {
            i++;
            if (cmd[i] == 'a')
            {
                write(STDOUT_FILENO, "\a", 1);
                i++;
            }
            else if (cmd[i] == 'b')
            {
                write(STDOUT_FILENO, "\b", 1);
                i++;
            }
            else if (cmd[i] == 'c')
            {
                *flag |= ECHO_N;
                break ;
            }
            else if (cmd[i] == 'f')
            {
                write(STDOUT_FILENO, "\f", 1);
                i++;
            }
            else if (cmd[i] == 'n')
            {
                write(STDOUT_FILENO, "\n", 1);
                i++;
            }
            else if (cmd[i] == 'r')
            {
                write(STDOUT_FILENO, "\r", 1);
                i++;
            }
            else if (cmd[i] == 't')
            {
                write(STDOUT_FILENO, "\t", 1);
                i++;
            }
            else if (cmd[i] == 'v')
            {
                write(STDOUT_FILENO, "\v", 1);
                i++;
            }
            else if (cmd[i] == '"' && i + 1 < len)
            {
                write(STDOUT_FILENO, "\"", 1);
                i++;
            }
            if (ft_strncmp(cmd + i, "033", 3) == 0
                || ft_strncmp(cmd + i, "x1b", 3) == 0)
            {
                write(STDOUT_FILENO, "\033", 1);
                i += 3;
            }
        }
        i += (cmd[i] == '\\' && !(*flag & ECHO_OQUT)) ? 1 : 0;
        if (cmd[i] != '"' && cmd[i] != '\\')
        {
            write(STDOUT_FILENO, &cmd[i], 1);
            i++;
        }
    }
    if ((*flag & ECHO_OQUT) && i >= len)
        write(STDOUT_FILENO, ">Close the brackets", 20);
}

write (STDOUT_FILENO, "New readline called: minishell is too baby for that", 51);

// if (cmd[i] == '\\')
		// {
		// 	if ((*flag & ECHO_OQUT) && (*flag & ECHO_E))
		// 	{
		// 		if (cmd[i + 1] == 'c')
		// 		{
		// 			*flag |= ECHO_N;
		// 			break ;
		// 		}
		// 		else
		// 		{
		// 			i = cmd_echo_escape(cmd, ++i);
		// 			continue ;
		// 		}
		// 	}
		// 	(cmd[i + 1] == '\\' || cmd[i + 1] == '\"') ?
		// 		write(STDOUT_FILENO, &cmd[++i], 1) : 0;
		// }


SPECIAL_SIGNS_PROCESSING
	printf("%.*s - %d - %s\n", tmp, environ[j], ft_strncmp(environ[j], cmd + i + 1, tmp - 1), cmd + i + 1);

!#$%'"\*





// if (cmd[3] == '\0')
	// {
	// 	ft_bzero(&pwd[4], (len_1 = ft_strlen(&pwd[4])));
	// 	if (len_1 < (len_2 = ft_strlen(&home[5])))
	// 		pwd = ft_realloc(pwd, len_1, len_2 + 1);
	// 	ft_strcpy(&pwd[4], &home[5]);
	// }
	// else if (cmd[3] == '-')
	// {
	// 	ft_bzero(&pwd[4], (len_1 = ft_strlen(&pwd[4])));
	// 	if (len_1 < (len_2 = ft_strlen(swap)))
	// 		pwd = ft_realloc(pwd, len_1, len_2 + 1);
	// 	ft_strcpy(&pwd[4], swap);
	// }
